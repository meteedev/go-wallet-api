
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>apperrs: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/KKGo-Software-engineering/fun-exercise-api/apperrs/error.go (80.0%)</option>
				
				<option value="file1">github.com/KKGo-Software-engineering/fun-exercise-api/apperrs/error_middleware.go (0.0%)</option>
				
				<option value="file2">github.com/KKGo-Software-engineering/fun-exercise-api/docs/docs.go (0.0%)</option>
				
				<option value="file3">github.com/KKGo-Software-engineering/fun-exercise-api/main.go (0.0%)</option>
				
				<option value="file4">github.com/KKGo-Software-engineering/fun-exercise-api/postgres/postgres.go (23.1%)</option>
				
				<option value="file5">github.com/KKGo-Software-engineering/fun-exercise-api/postgres/wallet.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package apperrs

import (
        "net/http"

        "github.com/labstack/echo/v4"
)

type AppError struct {
        Code    int    `json:"error_code"`
        Message string `json:"message"`
}

func (e AppError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

func NewNotFoundError(message string) error <span class="cov8" title="1">{
        return echo.NewHTTPError(http.StatusNotFound, message)
}</span>

func NewInternalServerError(message string) error <span class="cov8" title="1">{
        return echo.NewHTTPError(http.StatusInternalServerError, message)
}</span>

func NewUnprocessableEntity(message string) error <span class="cov8" title="1">{
        return echo.NewHTTPError(http.StatusUnprocessableEntity, message)
}</span>

func NewBadRequestError(message string) error <span class="cov8" title="1">{
        return echo.NewHTTPError(http.StatusBadRequest, message)
}</pre>
		
		<pre class="file" id="file1" style="display: none">package apperrs

import (
        "log"
        "net/http"

        "github.com/labstack/echo/v4"
)

type CustomError struct {
        Code    int    `json:"code"`
        Message string `json:"message"`
}


func CustomErrorMiddleware(next echo.HandlerFunc) echo.HandlerFunc <span class="cov0" title="0">{
        return func(c echo.Context) error </span><span class="cov0" title="0">{
                err := next(c) // Call the next handler
                if err != nil </span><span class="cov0" title="0">{
                        code := http.StatusInternalServerError
                        message := "Internal Server Error"

                        // Check for specific error types and customize error response
                        switch e := err.(type) </span>{
                        case *echo.HTTPError:<span class="cov0" title="0">
                                code = e.Code
                                message = e.Message.(string)</span>
                        default:<span class="cov0" title="0">
                                // Log the error for debugging purposes
                                log.Println(err)</span>
                        }

                        // Return standardized JSON response with error details
                        <span class="cov0" title="0">return c.JSON(code, CustomError{Code: code, Message: message})</span>
                }
                <span class="cov0" title="0">return nil</span>
        }
}</pre>
		
		<pre class="file" id="file2" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/api/v1/users/{id}/wallets": {
            "get": {
                "description": "Get user wallets",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "wallet"
                ],
                "summary": "Get user wallets",
                "parameters": [
                    {
                        "type": "string",
                        "description": "user id",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/wallet.Wallet"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/apperrs.CustomError"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/apperrs.CustomError"
                        }
                    }
                }
            },
            "delete": {
                "description": "Delete user wallets by user id",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "wallet"
                ],
                "summary": "Delete user wallets",
                "parameters": [
                    {
                        "type": "string",
                        "description": "user id",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/wallet.Wallet"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/apperrs.CustomError"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/apperrs.CustomError"
                        }
                    }
                }
            }
        },
        "/api/v1/wallets": {
            "get": {
                "description": "Get all wallets",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "wallet"
                ],
                "summary": "Get all wallets",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/wallet.Wallet"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/wallet.Err"
                        }
                    }
                }
            }
        },
        "/api/v1/wallets/": {
            "post": {
                "description": "Create user wallets",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "wallet"
                ],
                "summary": "Create user wallets",
                "parameters": [
                    {
                        "description": "WalletRequest",
                        "name": "WalletCreateRequest",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/wallet.WalletRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/wallet.Wallet"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/apperrs.CustomError"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/apperrs.CustomError"
                        }
                    }
                }
            }
        },
        "/api/v1/wallets/{id}": {
            "put": {
                "description": "Update user wallets by wallet id",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "wallet"
                ],
                "summary": "Update user wallets",
                "parameters": [
                    {
                        "type": "string",
                        "description": "wallet id",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "WalletRequest",
                        "name": "WalletCreateRequest",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/wallet.WalletRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/wallet.Wallet"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/apperrs.CustomError"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/apperrs.CustomError"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "apperrs.CustomError": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "integer"
                },
                "message": {
                    "type": "string"
                }
            }
        },
        "wallet.Err": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                }
            }
        },
        "wallet.Wallet": {
            "type": "object",
            "properties": {
                "balance": {
                    "type": "number",
                    "example": 100
                },
                "created_at": {
                    "type": "string",
                    "example": "2024-03-25T14:19:00.729237Z"
                },
                "id": {
                    "type": "integer",
                    "example": 1
                },
                "user_id": {
                    "type": "integer",
                    "example": 1
                },
                "user_name": {
                    "type": "string",
                    "example": "John Doe"
                },
                "wallet_name": {
                    "type": "string",
                    "example": "John's Wallet"
                },
                "wallet_type": {
                    "type": "string",
                    "example": "Create Card"
                }
            }
        },
        "wallet.WalletRequest": {
            "type": "object",
            "required": [
                "balance",
                "user_id",
                "user_name",
                "wallet_name",
                "wallet_type"
            ],
            "properties": {
                "balance": {
                    "type": "number",
                    "maximum": 10000,
                    "minimum": 500,
                    "example": 100
                },
                "user_id": {
                    "type": "integer",
                    "example": 1
                },
                "user_name": {
                    "type": "string",
                    "maxLength": 255,
                    "minLength": 3,
                    "example": "John Doe"
                },
                "wallet_name": {
                    "type": "string",
                    "maxLength": 255,
                    "minLength": 3,
                    "example": "John's Wallet"
                },
                "wallet_type": {
                    "type": "string",
                    "enum": [
                        "Savings",
                        "Credit Card",
                        "Crypto Wallet"
                    ],
                    "example": "Credit Card"
                }
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "localhost:1323",
        BasePath:         "",
        Schemes:          []string{},
        Title:            "Wallet API",
        Description:      "Sophisticated Wallet API",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        
        "github.com/KKGo-Software-engineering/fun-exercise-api/apperrs"
        "github.com/KKGo-Software-engineering/fun-exercise-api/postgres"
        "github.com/KKGo-Software-engineering/fun-exercise-api/wallet"
        "github.com/labstack/echo/v4"

        _ "github.com/KKGo-Software-engineering/fun-exercise-api/docs"
        echoSwagger "github.com/swaggo/echo-swagger"
)

//        @title                        Wallet API
//        @version                1.0
//        @description        Sophisticated Wallet API
//        @host                        localhost:1323
func main() <span class="cov0" title="0">{

        p, err := postgres.New()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">walletService := wallet.NewService(p)
        handler := wallet.NewHandler(walletService)
        
        e := echo.New()

        e.Use(apperrs.CustomErrorMiddleware)
        
        e.GET("/swagger/*", echoSwagger.WrapHandler)
        
        e.GET("/api/v1/wallets", handler.WalletHandler)
        e.POST("/api/v1/wallets", handler.CreateWalletHandler)
        e.PUT("/api/v1/wallets/:id",handler.UpdateWalletHandler)

        e.GET("/api/v1/users/:id/wallets", handler.WalletByUserIdHandler)
        e.POST("/api/v1/users/:id/wallets", handler.DeleteWalletHandler)
        
        e.Logger.Fatal(e.Start(":1323"))</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package postgres

import (
        "database/sql"
        "fmt"
        "log"
        "os"

        _ "github.com/lib/pq"
)

type DbConfiguration struct {
        Host     string
        Port     string
        User     string
        Password string
        DbName   string
        SslMode  string
}

func New() (*Postgres, error) <span class="cov0" title="0">{
        databaseSource := generateDatabaseUrl()
        log.Println(databaseSource)
        db, err := sql.Open("postgres", databaseSource)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">err = db.Ping()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">return &amp;Postgres{Db: db}, nil</span>
}

func initDbConfiguration() *DbConfiguration <span class="cov8" title="1">{
        return &amp;DbConfiguration{
                Host:     os.Getenv("POSTGRES_HOST"),
                Port:     os.Getenv("POSTGRES_PORT"),
                User:     os.Getenv("POSTGRES_USER"),
                Password: os.Getenv("POSTGRES_PASSWORD"),
                DbName:   os.Getenv("POSTGRES_DB_NAME"),
                SslMode:  os.Getenv("POSTGRES_SSL_MODE"),
        }
}</span>

func generateDatabaseUrl()string<span class="cov8" title="1">{
        dbConfig := initDbConfiguration()
        return fmt.Sprintf("host=%s port=%s user=%s "+
                "password=%s dbname=%s sslmode=%s",
                dbConfig.Host,
                dbConfig.Port, 
                dbConfig.User, 
                dbConfig.Password, 
                dbConfig.DbName,dbConfig.SslMode,
        )

}</pre>
		
		<pre class="file" id="file5" style="display: none">package postgres

import (
        "database/sql"
        "fmt"
        "reflect"
        "strings"
        "time"

        _ "github.com/lib/pq"
)

type Wallet struct {
        ID         int       `postgres:"id"`
        UserID     int       `postgres:"user_id"`
        UserName   string    `postgres:"user_name"`
        WalletName string    `postgres:"wallet_name"`
        WalletType string    `postgres:"wallet_type"`
        Balance    float64   `postgres:"balance"`
        CreatedAt  time.Time `postgres:"created_at"`
}



type Storer interface {
        FindAll() ([]Wallet, error)
        
        FindByWalletType(walletType string) ([]Wallet, error)
        
        FindByWalletId(walletID int) (*Wallet, error)
        
        FindByUserId(userId int) ([]Wallet, error)
        
        Create(wallet *Wallet) (*Wallet, error)
        
        CountByCriteria(criteria Wallet) (int, error)
        
        DeleteByUserId(userId string) (int64, error)
        
        UpdateByWalletId(walletId int,wallet Wallet)(int64,error)
}

type Postgres struct {
        Db *sql.DB
}

func (p *Postgres) FindByWalletType(walletType string) ([]Wallet, error) <span class="cov0" title="0">{
        rows, err := p.Db.Query("SELECT * FROM user_wallet WHERE wallet_type = $1", walletType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var wallets []Wallet
        for rows.Next() </span><span class="cov0" title="0">{
                var w Wallet
                err := rows.Scan(&amp;w.ID,
                        &amp;w.UserID, &amp;w.UserName,
                        &amp;w.WalletName, &amp;w.WalletType,
                        &amp;w.Balance, &amp;w.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">wallets = append(wallets, w)</span>
        }
        <span class="cov0" title="0">return wallets, nil</span>
}

func (p *Postgres) FindAll() ([]Wallet, error) <span class="cov0" title="0">{
        rows, err := p.Db.Query("SELECT * FROM user_wallet")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var wallets []Wallet
        for rows.Next() </span><span class="cov0" title="0">{
                var w Wallet
                err := rows.Scan(&amp;w.ID,
                        &amp;w.UserID, &amp;w.UserName,
                        &amp;w.WalletName, &amp;w.WalletType,
                        &amp;w.Balance, &amp;w.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">wallets = append(wallets, w)</span>
        }
        <span class="cov0" title="0">return wallets, nil</span>
}

func (p *Postgres) FindByUserId(userId int) ([]Wallet, error) <span class="cov0" title="0">{
        rows, err := p.Db.Query("SELECT * FROM user_wallet WHERE user_id = $1", userId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var wallets []Wallet
        for rows.Next() </span><span class="cov0" title="0">{
                var w Wallet
                err := rows.Scan(&amp;w.ID,
                        &amp;w.UserID, &amp;w.UserName,
                        &amp;w.WalletName, &amp;w.WalletType,
                        &amp;w.Balance, &amp;w.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">wallets = append(wallets, w)</span>
        }
        <span class="cov0" title="0">return wallets, nil</span>
}

func (p *Postgres) Create(w *Wallet) (*Wallet, error) <span class="cov0" title="0">{
        row := p.Db.QueryRow("INSERT INTO user_wallet (user_id, user_name, wallet_name, wallet_type, balance) values ($1, $2, $3, $4, $5) RETURNING id",
                w.UserID,
                w.UserName,
                w.WalletName, w.WalletType,
                w.Balance)

        err := row.Scan(&amp;w.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return w, err</span>
}

// func (p *Postgres) CountWalletsByCriteria(criteria *Wallet) (int, error) {
//     query := "SELECT count(id) FROM wallets WHERE "
//     var conditions []string
//     var args []interface{}

//     // Iterate over struct fields
//     v := reflect.ValueOf(criteria)
//     for i := 0; i &lt; v.NumField(); i++ {
//         fieldName := v.Type().Field(i).Tag.Get("postgres") // Get the tag value from struct definition
//         fieldValue := v.Field(i).Interface()               // Get the field value
//         if fieldValue != reflect.Zero(v.Field(i).Type()).Interface() {
//             conditions = append(conditions, fmt.Sprintf("%s = $%d", fieldName, len(args)+1))
//             args = append(args, fieldValue)
//         }
//     }

//     query += strings.Join(conditions, " AND ")

//     rows, err := p.Db.Query(query, args...)
//     if err != nil {
//         return nil, err
//     }
//     defer rows.Close()

//     var wallets []Wallet
//     for rows.Next() {
//         var wallet Wallet
//         err := rows.Scan(&amp;wallet.ID, &amp;wallet.UserID, &amp;wallet.UserName, &amp;wallet.WalletName, &amp;wallet.WalletType, &amp;wallet.Balance, &amp;wallet.CreatedAt)
//         if err != nil {
//             return nil, fmt.Errorf("error scanning wallet row: %v", err)
//         }
//         wallets = append(wallets, wallet)
//     }
//     if err := rows.Err(); err != nil {
//         return nil, fmt.Errorf("error iterating over wallet rows: %v", err)
//     }

//     return wallets, nil
// }

func (p *Postgres) CountByCriteria(criteria Wallet) (int, error) <span class="cov0" title="0">{
        query := "SELECT count(id) FROM user_wallet WHERE "
        var args []interface{}

        // Iterate over struct fields
        var sb strings.Builder
        v := reflect.ValueOf(criteria)
        for i := 0; i &lt; v.NumField(); i++ </span><span class="cov0" title="0">{
                fieldName := v.Type().Field(i).Tag.Get("postgres") // Get the tag value from struct definition
                fieldValue := v.Field(i).Interface()               // Get the field value
                if fieldValue != reflect.Zero(v.Field(i).Type()).Interface() </span><span class="cov0" title="0">{
                        if sb.Len() &gt; 0 </span><span class="cov0" title="0">{
                                sb.WriteString(" AND ") // Add AND if there are multiple conditions
                        }</span>
                        <span class="cov0" title="0">sb.WriteString(fmt.Sprintf("%s = $%d", fieldName, len(args)+1))
                        args = append(args, fieldValue)</span>
                }
        }

        <span class="cov0" title="0">query += sb.String()

        row := p.Db.QueryRow(query, args...)

        var count int
        err := row.Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return count, nil</span>

}

func (p *Postgres) DeleteByUserId(userId string) (int64, error) <span class="cov0" title="0">{

        sql := "DELETE FROM user_wallet WHERE user_id= $1"
        res, err := p.Db.Exec(sql, userId)

        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">deletedRows, err := res.RowsAffected()

        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return deletedRows, nil</span>
}


func (p *Postgres) FindByWalletId(walletID int) (*Wallet, error) <span class="cov0" title="0">{
    // Prepare the SQL query with a placeholder for the wallet ID
    query := `
        SELECT id, user_id, user_name, wallet_name, wallet_type, balance, created_at 
        FROM user_wallet 
        WHERE id = $1 
        LIMIT 1
    `

    // Execute the query using the QueryRow method of the DB object
    row := p.Db.QueryRow(query, walletID)

    // Initialize a Wallet struct
    var wallet Wallet

    // Scan the values returned by the query into the fields of the wallet struct
    err := row.Scan(&amp;wallet.ID, &amp;wallet.UserID, &amp;wallet.UserName, &amp;wallet.WalletName, &amp;wallet.WalletType, &amp;wallet.Balance, &amp;wallet.CreatedAt)
    if err != nil </span><span class="cov0" title="0">{
        // If no rows are returned, check for sql.ErrNoRows error
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
            return nil, fmt.Errorf("wallet not found for ID: %d", walletID)
        }</span>
        // Otherwise, return any other error
        <span class="cov0" title="0">return nil, err</span>
    }

    // Return the populated wallet pointer
    <span class="cov0" title="0">return &amp;wallet, nil</span>
}

func (p *Postgres) UpdateByWalletId(walletId int, wallet Wallet) (int64, error) <span class="cov0" title="0">{
    var updates []string
    var args []interface{}

    val := reflect.ValueOf(wallet)
    typ := reflect.TypeOf(wallet)

    for i := 0; i &lt; val.NumField(); i++ </span><span class="cov0" title="0">{
        field := val.Field(i)
        tag := typ.Field(i).Tag.Get("postgres")

        if field.IsZero() || !field.CanInterface() </span><span class="cov0" title="0">{
            continue</span>
        }

        <span class="cov0" title="0">updates = append(updates, fmt.Sprintf("%s = $%d", tag, len(args)+1))
        args = append(args, field.Interface())</span>
    }

    // Check if any updates are provided
    <span class="cov0" title="0">if len(updates) == 0 </span><span class="cov0" title="0">{
        return 0, fmt.Errorf("no updates provided")
    }</span>

    // Construct the query string
    <span class="cov0" title="0">query := fmt.Sprintf("UPDATE user_wallet SET %s WHERE id = $%d", strings.Join(updates, ", "), len(args)+1)
    args = append(args, walletId)

    // Execute the query
    res, err := p.Db.Exec(query, args...)
    if err != nil </span><span class="cov0" title="0">{
        return 0, err
    }</span>

    // Get the number of rows affected
    <span class="cov0" title="0">numRows, err := res.RowsAffected()
    if err != nil </span><span class="cov0" title="0">{
        return 0, err
    }</span>

    <span class="cov0" title="0">return numRows, nil</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
