
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>apperrs: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/KKGo-Software-engineering/fun-exercise-api/apperrs/error.go (80.0%)</option>
				
				<option value="file1">github.com/KKGo-Software-engineering/fun-exercise-api/apperrs/error_middleware.go (0.0%)</option>
				
				<option value="file2">github.com/KKGo-Software-engineering/fun-exercise-api/docs/docs.go (0.0%)</option>
				
				<option value="file3">github.com/KKGo-Software-engineering/fun-exercise-api/main.go (0.0%)</option>
				
				<option value="file4">github.com/KKGo-Software-engineering/fun-exercise-api/postgres/postgres.go (23.1%)</option>
				
				<option value="file5">github.com/KKGo-Software-engineering/fun-exercise-api/postgres/wallet.go (0.0%)</option>
				
				<option value="file6">github.com/KKGo-Software-engineering/fun-exercise-api/wallet/handler.go (73.2%)</option>
				
				<option value="file7">github.com/KKGo-Software-engineering/fun-exercise-api/wallet/wallet_service.go (0.0%)</option>
				
				<option value="file8">github.com/KKGo-Software-engineering/fun-exercise-api/wallet/wallet_service_mock.go (76.9%)</option>
				
				<option value="file9">github.com/KKGo-Software-engineering/fun-exercise-api/wallet/wallet_validate_manual.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package apperrs

import (
        "net/http"

        "github.com/labstack/echo/v4"
)

type AppError struct {
        Code    int    `json:"error_code"`
        Message string `json:"message"`
}

func (e AppError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

func NewNotFoundError(message string) error <span class="cov8" title="1">{
        return echo.NewHTTPError(http.StatusNotFound, message)
}</span>

func NewInternalServerError(message string) error <span class="cov8" title="1">{
        return echo.NewHTTPError(http.StatusInternalServerError, message)
}</span>

func NewUnprocessableEntity(message string) error <span class="cov8" title="1">{
        return echo.NewHTTPError(http.StatusUnprocessableEntity, message)
}</span>

func NewBadRequestError(message string) error <span class="cov8" title="1">{
        return echo.NewHTTPError(http.StatusBadRequest, message)
}</pre>
		
		<pre class="file" id="file1" style="display: none">package apperrs

import (
        "log"
        "net/http"

        "github.com/labstack/echo/v4"
)

type CustomError struct {
        Code    int    `json:"code"`
        Message string `json:"message"`
}


func CustomErrorMiddleware(next echo.HandlerFunc) echo.HandlerFunc <span class="cov0" title="0">{
        return func(c echo.Context) error </span><span class="cov0" title="0">{
                err := next(c) // Call the next handler
                if err != nil </span><span class="cov0" title="0">{
                        code := http.StatusInternalServerError
                        message := "Internal Server Error"

                        // Check for specific error types and customize error response
                        switch e := err.(type) </span>{
                        case *echo.HTTPError:<span class="cov0" title="0">
                                code = e.Code
                                message = e.Message.(string)</span>
                        default:<span class="cov0" title="0">
                                // Log the error for debugging purposes
                                log.Println(err)</span>
                        }

                        // Return standardized JSON response with error details
                        <span class="cov0" title="0">return c.JSON(code, CustomError{Code: code, Message: message})</span>
                }
                <span class="cov0" title="0">return nil</span>
        }
}</pre>
		
		<pre class="file" id="file2" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/api/v1/users/{id}/wallets": {
            "get": {
                "description": "Get user wallets",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "wallet"
                ],
                "summary": "Get user wallets",
                "parameters": [
                    {
                        "type": "string",
                        "description": "user id",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/wallet.Wallet"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/apperrs.CustomError"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/apperrs.CustomError"
                        }
                    }
                }
            },
            "delete": {
                "description": "Delete user wallets by user id",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "wallet"
                ],
                "summary": "Delete user wallets",
                "parameters": [
                    {
                        "type": "string",
                        "description": "user id",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/wallet.Wallet"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/apperrs.CustomError"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/apperrs.CustomError"
                        }
                    }
                }
            }
        },
        "/api/v1/wallets": {
            "get": {
                "description": "Get all wallets",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "wallet"
                ],
                "summary": "Get all wallets",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/wallet.Wallet"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/wallet.Err"
                        }
                    }
                }
            }
        },
        "/api/v1/wallets/": {
            "post": {
                "description": "Create user wallets",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "wallet"
                ],
                "summary": "Create user wallets",
                "parameters": [
                    {
                        "description": "WalletRequest",
                        "name": "WalletCreateRequest",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/wallet.WalletRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/wallet.Wallet"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/apperrs.CustomError"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/apperrs.CustomError"
                        }
                    }
                }
            }
        },
        "/api/v1/wallets/{id}": {
            "put": {
                "description": "Update user wallets by wallet id",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "wallet"
                ],
                "summary": "Update user wallets",
                "parameters": [
                    {
                        "type": "string",
                        "description": "wallet id",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "WalletRequest",
                        "name": "WalletCreateRequest",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/wallet.WalletRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/wallet.Wallet"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/apperrs.CustomError"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/apperrs.CustomError"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "apperrs.CustomError": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "integer"
                },
                "message": {
                    "type": "string"
                }
            }
        },
        "wallet.Err": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                }
            }
        },
        "wallet.Wallet": {
            "type": "object",
            "properties": {
                "balance": {
                    "type": "number",
                    "example": 100
                },
                "created_at": {
                    "type": "string",
                    "example": "2024-03-25T14:19:00.729237Z"
                },
                "id": {
                    "type": "integer",
                    "example": 1
                },
                "user_id": {
                    "type": "integer",
                    "example": 1
                },
                "user_name": {
                    "type": "string",
                    "example": "John Doe"
                },
                "wallet_name": {
                    "type": "string",
                    "example": "John's Wallet"
                },
                "wallet_type": {
                    "type": "string",
                    "example": "Create Card"
                }
            }
        },
        "wallet.WalletRequest": {
            "type": "object",
            "required": [
                "balance",
                "user_id",
                "user_name",
                "wallet_name",
                "wallet_type"
            ],
            "properties": {
                "balance": {
                    "type": "number",
                    "maximum": 10000,
                    "minimum": 500,
                    "example": 100
                },
                "user_id": {
                    "type": "integer",
                    "example": 1
                },
                "user_name": {
                    "type": "string",
                    "maxLength": 255,
                    "minLength": 3,
                    "example": "John Doe"
                },
                "wallet_name": {
                    "type": "string",
                    "maxLength": 255,
                    "minLength": 3,
                    "example": "John's Wallet"
                },
                "wallet_type": {
                    "type": "string",
                    "enum": [
                        "Savings",
                        "Credit Card",
                        "Crypto Wallet"
                    ],
                    "example": "Credit Card"
                }
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "localhost:1323",
        BasePath:         "",
        Schemes:          []string{},
        Title:            "Wallet API",
        Description:      "Sophisticated Wallet API",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        
        "github.com/KKGo-Software-engineering/fun-exercise-api/apperrs"
        "github.com/KKGo-Software-engineering/fun-exercise-api/postgres"
        "github.com/KKGo-Software-engineering/fun-exercise-api/wallet"
        "github.com/labstack/echo/v4"

        _ "github.com/KKGo-Software-engineering/fun-exercise-api/docs"
        echoSwagger "github.com/swaggo/echo-swagger"
)

//        @title                        Wallet API
//        @version                1.0
//        @description        Sophisticated Wallet API
//        @host                        localhost:1323
func main() <span class="cov0" title="0">{

        p, err := postgres.New()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">walletService := wallet.NewService(p)
        handler := wallet.NewHandler(walletService)
        
        e := echo.New()

        e.Use(apperrs.CustomErrorMiddleware)
        
        e.GET("/swagger/*", echoSwagger.WrapHandler)
        
        e.GET("/api/v1/wallets", handler.WalletHandler)
        e.POST("/api/v1/wallets", handler.CreateWalletHandler)
        e.PUT("/api/v1/wallets/:id",handler.UpdateWalletHandler)

        e.GET("/api/v1/users/:id/wallets", handler.WalletByUserIdHandler)
        e.POST("/api/v1/users/:id/wallets", handler.DeleteWalletHandler)
        
        e.Logger.Fatal(e.Start(":1323"))</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package postgres

import (
        "database/sql"
        "fmt"
        "log"
        "os"

        _ "github.com/lib/pq"
)

type DbConfiguration struct {
        Host     string
        Port     string
        User     string
        Password string
        DbName   string
        SslMode  string
}

func New() (*Postgres, error) <span class="cov0" title="0">{
        databaseSource := generateDatabaseUrl()
        log.Println(databaseSource)
        db, err := sql.Open("postgres", databaseSource)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">err = db.Ping()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">return &amp;Postgres{Db: db}, nil</span>
}

func initDbConfiguration() *DbConfiguration <span class="cov8" title="1">{
        return &amp;DbConfiguration{
                Host:     os.Getenv("POSTGRES_HOST"),
                Port:     os.Getenv("POSTGRES_PORT"),
                User:     os.Getenv("POSTGRES_USER"),
                Password: os.Getenv("POSTGRES_PASSWORD"),
                DbName:   os.Getenv("POSTGRES_DB_NAME"),
                SslMode:  os.Getenv("POSTGRES_SSL_MODE"),
        }
}</span>

func generateDatabaseUrl()string<span class="cov8" title="1">{
        dbConfig := initDbConfiguration()
        return fmt.Sprintf("host=%s port=%s user=%s "+
                "password=%s dbname=%s sslmode=%s",
                dbConfig.Host,
                dbConfig.Port, 
                dbConfig.User, 
                dbConfig.Password, 
                dbConfig.DbName,dbConfig.SslMode,
        )

}</pre>
		
		<pre class="file" id="file5" style="display: none">package postgres

import (
        "database/sql"
        "fmt"
        "reflect"
        "strings"
        "time"

        _ "github.com/lib/pq"
)

type Wallet struct {
        ID         int       `postgres:"id"`
        UserID     int       `postgres:"user_id"`
        UserName   string    `postgres:"user_name"`
        WalletName string    `postgres:"wallet_name"`
        WalletType string    `postgres:"wallet_type"`
        Balance    float64   `postgres:"balance"`
        CreatedAt  time.Time `postgres:"created_at"`
}



type Storer interface {
        FindAll() ([]Wallet, error)
        
        FindByWalletType(walletType string) ([]Wallet, error)
        
        FindByWalletId(walletID int) (*Wallet, error)
        
        FindByUserId(userId int) ([]Wallet, error)
        
        Create(wallet *Wallet) (*Wallet, error)
        
        CountByCriteria(criteria Wallet) (int, error)
        
        DeleteByUserId(userId string) (int64, error)
        
        UpdateByWalletId(walletId int,wallet Wallet)(int64,error)
}

type Postgres struct {
        Db *sql.DB
}

func (p *Postgres) FindByWalletType(walletType string) ([]Wallet, error) <span class="cov0" title="0">{
        rows, err := p.Db.Query("SELECT * FROM user_wallet WHERE wallet_type = $1", walletType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var wallets []Wallet
        for rows.Next() </span><span class="cov0" title="0">{
                var w Wallet
                err := rows.Scan(&amp;w.ID,
                        &amp;w.UserID, &amp;w.UserName,
                        &amp;w.WalletName, &amp;w.WalletType,
                        &amp;w.Balance, &amp;w.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">wallets = append(wallets, w)</span>
        }
        <span class="cov0" title="0">return wallets, nil</span>
}

func (p *Postgres) FindAll() ([]Wallet, error) <span class="cov0" title="0">{
        rows, err := p.Db.Query("SELECT * FROM user_wallet")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var wallets []Wallet
        for rows.Next() </span><span class="cov0" title="0">{
                var w Wallet
                err := rows.Scan(&amp;w.ID,
                        &amp;w.UserID, &amp;w.UserName,
                        &amp;w.WalletName, &amp;w.WalletType,
                        &amp;w.Balance, &amp;w.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">wallets = append(wallets, w)</span>
        }
        <span class="cov0" title="0">return wallets, nil</span>
}

func (p *Postgres) FindByUserId(userId int) ([]Wallet, error) <span class="cov0" title="0">{
        rows, err := p.Db.Query("SELECT * FROM user_wallet WHERE user_id = $1", userId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var wallets []Wallet
        for rows.Next() </span><span class="cov0" title="0">{
                var w Wallet
                err := rows.Scan(&amp;w.ID,
                        &amp;w.UserID, &amp;w.UserName,
                        &amp;w.WalletName, &amp;w.WalletType,
                        &amp;w.Balance, &amp;w.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">wallets = append(wallets, w)</span>
        }
        <span class="cov0" title="0">return wallets, nil</span>
}

func (p *Postgres) Create(w *Wallet) (*Wallet, error) <span class="cov0" title="0">{
        row := p.Db.QueryRow("INSERT INTO user_wallet (user_id, user_name, wallet_name, wallet_type, balance) values ($1, $2, $3, $4, $5) RETURNING id",
                w.UserID,
                w.UserName,
                w.WalletName, w.WalletType,
                w.Balance)

        err := row.Scan(&amp;w.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return w, err</span>
}

// func (p *Postgres) CountWalletsByCriteria(criteria *Wallet) (int, error) {
//     query := "SELECT count(id) FROM wallets WHERE "
//     var conditions []string
//     var args []interface{}

//     // Iterate over struct fields
//     v := reflect.ValueOf(criteria)
//     for i := 0; i &lt; v.NumField(); i++ {
//         fieldName := v.Type().Field(i).Tag.Get("postgres") // Get the tag value from struct definition
//         fieldValue := v.Field(i).Interface()               // Get the field value
//         if fieldValue != reflect.Zero(v.Field(i).Type()).Interface() {
//             conditions = append(conditions, fmt.Sprintf("%s = $%d", fieldName, len(args)+1))
//             args = append(args, fieldValue)
//         }
//     }

//     query += strings.Join(conditions, " AND ")

//     rows, err := p.Db.Query(query, args...)
//     if err != nil {
//         return nil, err
//     }
//     defer rows.Close()

//     var wallets []Wallet
//     for rows.Next() {
//         var wallet Wallet
//         err := rows.Scan(&amp;wallet.ID, &amp;wallet.UserID, &amp;wallet.UserName, &amp;wallet.WalletName, &amp;wallet.WalletType, &amp;wallet.Balance, &amp;wallet.CreatedAt)
//         if err != nil {
//             return nil, fmt.Errorf("error scanning wallet row: %v", err)
//         }
//         wallets = append(wallets, wallet)
//     }
//     if err := rows.Err(); err != nil {
//         return nil, fmt.Errorf("error iterating over wallet rows: %v", err)
//     }

//     return wallets, nil
// }

func (p *Postgres) CountByCriteria(criteria Wallet) (int, error) <span class="cov0" title="0">{
        query := "SELECT count(id) FROM user_wallet WHERE "
        var args []interface{}

        // Iterate over struct fields
        var sb strings.Builder
        v := reflect.ValueOf(criteria)
        for i := 0; i &lt; v.NumField(); i++ </span><span class="cov0" title="0">{
                fieldName := v.Type().Field(i).Tag.Get("postgres") // Get the tag value from struct definition
                fieldValue := v.Field(i).Interface()               // Get the field value
                if fieldValue != reflect.Zero(v.Field(i).Type()).Interface() </span><span class="cov0" title="0">{
                        if sb.Len() &gt; 0 </span><span class="cov0" title="0">{
                                sb.WriteString(" AND ") // Add AND if there are multiple conditions
                        }</span>
                        <span class="cov0" title="0">sb.WriteString(fmt.Sprintf("%s = $%d", fieldName, len(args)+1))
                        args = append(args, fieldValue)</span>
                }
        }

        <span class="cov0" title="0">query += sb.String()

        row := p.Db.QueryRow(query, args...)

        var count int
        err := row.Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return count, nil</span>

}

func (p *Postgres) DeleteByUserId(userId string) (int64, error) <span class="cov0" title="0">{

        sql := "DELETE FROM user_wallet WHERE user_id= $1"
        res, err := p.Db.Exec(sql, userId)

        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">deletedRows, err := res.RowsAffected()

        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return deletedRows, nil</span>
}


func (p *Postgres) FindByWalletId(walletID int) (*Wallet, error) <span class="cov0" title="0">{
    // Prepare the SQL query with a placeholder for the wallet ID
    query := `
        SELECT id, user_id, user_name, wallet_name, wallet_type, balance, created_at 
        FROM user_wallet 
        WHERE id = $1 
        LIMIT 1
    `

    // Execute the query using the QueryRow method of the DB object
    row := p.Db.QueryRow(query, walletID)

    // Initialize a Wallet struct
    var wallet Wallet

    // Scan the values returned by the query into the fields of the wallet struct
    err := row.Scan(&amp;wallet.ID, &amp;wallet.UserID, &amp;wallet.UserName, &amp;wallet.WalletName, &amp;wallet.WalletType, &amp;wallet.Balance, &amp;wallet.CreatedAt)
    if err != nil </span><span class="cov0" title="0">{
        // If no rows are returned, check for sql.ErrNoRows error
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
            return nil, fmt.Errorf("wallet not found for ID: %d", walletID)
        }</span>
        // Otherwise, return any other error
        <span class="cov0" title="0">return nil, err</span>
    }

    // Return the populated wallet pointer
    <span class="cov0" title="0">return &amp;wallet, nil</span>
}

func (p *Postgres) UpdateByWalletId(walletId int, wallet Wallet) (int64, error) <span class="cov0" title="0">{
    var updates []string
    var args []interface{}

    val := reflect.ValueOf(wallet)
    typ := reflect.TypeOf(wallet)

    for i := 0; i &lt; val.NumField(); i++ </span><span class="cov0" title="0">{
        field := val.Field(i)
        tag := typ.Field(i).Tag.Get("postgres")

        if field.IsZero() || !field.CanInterface() </span><span class="cov0" title="0">{
            continue</span>
        }

        <span class="cov0" title="0">updates = append(updates, fmt.Sprintf("%s = $%d", tag, len(args)+1))
        args = append(args, field.Interface())</span>
    }

    // Check if any updates are provided
    <span class="cov0" title="0">if len(updates) == 0 </span><span class="cov0" title="0">{
        return 0, fmt.Errorf("no updates provided")
    }</span>

    // Construct the query string
    <span class="cov0" title="0">query := fmt.Sprintf("UPDATE user_wallet SET %s WHERE id = $%d", strings.Join(updates, ", "), len(args)+1)
    args = append(args, walletId)

    // Execute the query
    res, err := p.Db.Exec(query, args...)
    if err != nil </span><span class="cov0" title="0">{
        return 0, err
    }</span>

    // Get the number of rows affected
    <span class="cov0" title="0">numRows, err := res.RowsAffected()
    if err != nil </span><span class="cov0" title="0">{
        return 0, err
    }</span>

    <span class="cov0" title="0">return numRows, nil</span>
}</pre>
		
		<pre class="file" id="file6" style="display: none">package wallet

import (
        "net/http"
        "strconv"

        "github.com/KKGo-Software-engineering/fun-exercise-api/apperrs"
        "github.com/labstack/echo/v4"
)

type Handler struct {
        service Service
}

func NewHandler(service Service) *Handler <span class="cov8" title="1">{
        return &amp;Handler{service: service}
}</span>

type Err struct {
        Message string `json:"message"`
}

// WalletHandler
//
//        @Summary                Get all wallets
//        @Description        Get all wallets
//        @Tags                        wallet
//        @Accept                        json
//        @Produce                json
//        @Success                200        {object}        Wallet
//        @Router                        /api/v1/wallets [get]
//        @Failure                500        {object}        Err
func (h *Handler) WalletHandler(c echo.Context) error <span class="cov8" title="1">{

        walletType := c.QueryParam("wallet_type")

        var wallets []Wallet
        var err error

        if walletType != "" </span><span class="cov0" title="0">{
                wallets, err = h.service.GetWalletsByWalletType(walletType)
        }</span> else<span class="cov8" title="1"> {
                wallets, err = h.service.GetAllWallets()
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, wallets)</span>

}



// UserHandler
//        @Summary                Get user wallets
//        @Description        Get user wallets
//        @Tags                        wallet
//        @Accept                        json
//        @Produce                json
//        @Success                200        {object}        Wallet
//        @Router                        /api/v1/users/{id}/wallets [get]
//        @Param                        id        path        string        true        "user id"
//        @Failure                500        {object}        apperrs.CustomError
//        @Failure                400        {object}        apperrs.CustomError
func (h *Handler) WalletByUserIdHandler(c echo.Context) error <span class="cov8" title="1">{
        userId , err := strconv.Atoi(c.Param("id"))

        if err != nil </span><span class="cov0" title="0">{
        return apperrs.NewBadRequestError("invalid user ID")
    }</span>

        <span class="cov8" title="1">wallets, err := h.service.GetWalletsByUserId(userId)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, wallets)</span>

}



// CreateWallet
// @Summary Create user wallets
// @Description Create user wallets
// @Tags wallet
// @Accept json
// @Produce json
// @Param WalletCreateRequest body WalletRequest true "WalletRequest"
// @Success 201 {object} Wallet
// @Router /api/v1/wallets/ [post]
// @Failure 500 {object} apperrs.CustomError
// @Failure 400 {object} apperrs.CustomError
func (h *Handler) CreateWalletHandler(c echo.Context) error <span class="cov8" title="1">{

        req := new(WalletRequest)
        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">wallet, err := h.service.CreateWallet(req)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusCreated, wallet)</span>
}


// DeleteWallet
// @Summary Delete user wallets
// @Description Delete user wallets by user id
// @Tags wallet
// @Accept json
// @Produce json
// @Router        /api/v1/users/{id}/wallets [delete]
// @Param        id        path        string        true        "user id"
// @Success 200 {object} Wallet
// @Failure 500 {object} apperrs.CustomError
// @Failure 400 {object} apperrs.CustomError
func (h *Handler) DeleteWalletHandler(c echo.Context) error <span class="cov8" title="1">{

        userId := c.Param("id")

        if len(userId) == 0 </span><span class="cov0" title="0">{
                return apperrs.NewBadRequestError("user id required")
        }</span>

        <span class="cov8" title="1">rowAffected, err := h.service.DeleteWalletByUserId(userId)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, rowAffected)</span>

}


// UpdateWallet
// @Summary Update user wallets
// @Description Update user wallets by wallet id
// @Tags wallet
// @Accept json
// @Produce json
// @Router /api/v1/wallets/{id} [put]
// @Param        id        path        string        true        "wallet id"
// @Param WalletCreateRequest body WalletRequest true "WalletRequest"
// @Success 200 {object} Wallet
// @Failure 500 {object} apperrs.CustomError
// @Failure 400 {object} apperrs.CustomError
func (h *Handler) UpdateWalletHandler(c echo.Context) error <span class="cov8" title="1">{

        walletId , err := strconv.Atoi(c.Param("id"))

        if err != nil </span><span class="cov0" title="0">{
        return apperrs.NewBadRequestError("invalid wallet ID")
    }</span>


        <span class="cov8" title="1">req := new(WalletRequest)
        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">walletResponse, err := h.service.UpdateWalletByWalletId(walletId, req)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, walletResponse)</span>

}
</pre>
		
		<pre class="file" id="file7" style="display: none">package wallet

import (
        "log"

        "github.com/KKGo-Software-engineering/fun-exercise-api/apperrs"
        "github.com/KKGo-Software-engineering/fun-exercise-api/postgres"
)

type WalletService struct {
        WalletStore postgres.Storer
}


func NewService(db postgres.Storer) WalletService <span class="cov0" title="0">{
        return WalletService{WalletStore: db}
}</span>

func (s WalletService) GetAllWallets() ([]Wallet, error)<span class="cov0" title="0">{

        wallets, err := s.WalletStore.FindAll()

        if err != nil </span><span class="cov0" title="0">{
                return nil, apperrs.NewInternalServerError(err.Error())
        }</span>

        <span class="cov0" title="0">if len(wallets)==0</span><span class="cov0" title="0">{
                return nil, apperrs.NewNotFoundError("wallet not found")
        }</span>

        <span class="cov0" title="0">var walletResponses []Wallet
        for _, w := range wallets </span><span class="cov0" title="0">{
                walletResponses = append(walletResponses, Wallet{
                        ID:         w.ID,
                        UserID:     w.UserID,
                        UserName:   w.UserName,
                        WalletName: w.WalletName,
                        WalletType: w.WalletType,
                        Balance:    w.Balance,
                        CreatedAt:  w.CreatedAt,
                })
        }</span>

        <span class="cov0" title="0">return walletResponses,nil</span>

}


func (s WalletService) GetWalletsByWalletType(walletType string) ([]Wallet, error)<span class="cov0" title="0">{

        wallets, err := s.WalletStore.FindByWalletType(walletType)

        if err != nil </span><span class="cov0" title="0">{
                return nil, apperrs.NewInternalServerError(err.Error())
        }</span>

        <span class="cov0" title="0">if len(wallets)==0</span><span class="cov0" title="0">{
                return nil, apperrs.NewNotFoundError("wallet not found")
        }</span>

        <span class="cov0" title="0">var walletResponses []Wallet
        for _, w := range wallets </span><span class="cov0" title="0">{
                walletResponses = append(walletResponses, Wallet{
                        ID:         w.ID,
                        UserID:     w.UserID,
                        UserName:   w.UserName,
                        WalletName: w.WalletName,
                        WalletType: w.WalletType,
                        Balance:    w.Balance,
                        CreatedAt:  w.CreatedAt,
                })
        }</span>

        <span class="cov0" title="0">return walletResponses,nil</span>

}


func (s WalletService) GetWalletsByUserId(userId int) ([]Wallet, error)<span class="cov0" title="0">{

        wallets, err := s.WalletStore.FindByUserId(userId)

        if err != nil </span><span class="cov0" title="0">{
                return nil, apperrs.NewInternalServerError(err.Error())
        }</span>

        <span class="cov0" title="0">if len(wallets)==0</span><span class="cov0" title="0">{
                return nil, apperrs.NewNotFoundError("wallet not found")
        }</span>

        <span class="cov0" title="0">var walletResponses []Wallet
        for _, w := range wallets </span><span class="cov0" title="0">{
                walletResponses = append(walletResponses, Wallet{
                        ID:         w.ID,
                        UserID:     w.UserID,
                        UserName:   w.UserName,
                        WalletName: w.WalletName,
                        WalletType: w.WalletType,
                        Balance:    w.Balance,
                        CreatedAt:  w.CreatedAt,
                })
        }</span>

        <span class="cov0" title="0">return walletResponses,nil</span>

}


func (ws WalletService) CreateWallet(request *WalletRequest) (*Wallet,error)<span class="cov0" title="0">{
        
        
        err := ValidateWalletRequest(request)

        if err != nil</span><span class="cov0" title="0">{
                log.Println(err)
                return nil,apperrs.NewBadRequestError(err.Error())
        }</span>

        <span class="cov0" title="0">wallet := postgres.Wallet{
                UserID:     request.UserID,
                UserName:   request.UserName,
                WalletName: request.WalletName,
                WalletType: request.WalletType,
                Balance:    request.Balance,
        }

        isDuplicated , err := ws.checkDuplicated(wallet)

        if err != nil</span><span class="cov0" title="0">{
                log.Println(err)
                return nil,apperrs.NewInternalServerError(err.Error())
        }</span>

        <span class="cov0" title="0">if isDuplicated </span><span class="cov0" title="0">{
                log.Printf("Duplicated wallet userid=%d userName=%s walletname=%s walletType=%s",wallet.UserID,wallet.UserName,wallet.WalletName,wallet.WalletType)
                return nil,apperrs.NewInternalServerError("Duplicated wallets")
        }</span>

        
        <span class="cov0" title="0">w , err := ws.WalletStore.Create(&amp;wallet)
        
        if err != nil</span><span class="cov0" title="0">{
                log.Println(err)
                return nil,apperrs.NewInternalServerError("Create wallet failed")
        }</span>

        <span class="cov0" title="0">walletResponses := Wallet{
                ID:         w.ID,
                UserID:     w.UserID,
                UserName:   w.UserName,
                WalletName: w.WalletName,
                WalletType: w.WalletType,
                Balance:    w.Balance,
                CreatedAt:  w.CreatedAt,
        }


        return &amp;walletResponses,nil</span>
}

func (ws WalletService) checkDuplicated(wallet postgres.Wallet) (bool,error)<span class="cov0" title="0">{
        rowCount , err := ws.WalletStore.CountByCriteria(wallet)
        
        if err!= nil</span><span class="cov0" title="0">{
                return false,err
        }</span>

        <span class="cov0" title="0">isDup := rowCount &gt; 0

        return isDup , nil</span>
}



func (ws WalletService) DeleteWalletByUserId(userId string)(int64,error)<span class="cov0" title="0">{
        
        deleteRow , err := ws.WalletStore.DeleteByUserId(userId)
        

        if err != nil</span><span class="cov0" title="0">{
                log.Println(err)
                return 0,apperrs.NewInternalServerError("Delete wallet failed")
        }</span>
        
        <span class="cov0" title="0">if deleteRow == 0</span><span class="cov0" title="0">{
                log.Println("delete affected ",deleteRow)
                return 0,apperrs.NewUnprocessableEntity("Delete wallet failed")
        }</span>

        <span class="cov0" title="0">return deleteRow,nil</span>
}


func (ws WalletService) UpdateWalletByWalletId(walletId int,request *WalletRequest) (*Wallet,error)<span class="cov0" title="0">{
        
        err := ValidateWalletRequest(request)

        if err != nil</span><span class="cov0" title="0">{
                log.Println(err)
                return nil,apperrs.NewBadRequestError(err.Error())
        }</span>
        
        
        <span class="cov0" title="0">wallet := postgres.Wallet{
                UserID:     request.UserID,
                UserName:   request.UserName,
                WalletName: request.WalletName,
                WalletType: request.WalletType,
                Balance:    request.Balance,
        }

        updateRow , err := ws.WalletStore.UpdateByWalletId(walletId,wallet)
        

        if err != nil</span><span class="cov0" title="0">{
                log.Println(err)
                return nil,apperrs.NewInternalServerError("Update wallet failed")
        }</span>
        
        <span class="cov0" title="0">if updateRow == 0</span><span class="cov0" title="0">{
                log.Println("update affected ",updateRow)
                return nil,apperrs.NewUnprocessableEntity("Delete wallet failed")
        }</span>

        <span class="cov0" title="0">w , err := ws.WalletStore.FindByWalletId(walletId)

        if err != nil</span><span class="cov0" title="0">{
                log.Println(err)
                return nil,apperrs.NewInternalServerError("Update wallet failed")
        }</span>

        <span class="cov0" title="0">walletResponses := Wallet{
                ID:         w.ID,
                UserID:     w.UserID,
                UserName:   w.UserName,
                WalletName: w.WalletName,
                WalletType: w.WalletType,
                Balance:    w.Balance,
                CreatedAt:  w.CreatedAt,
        }

        return &amp;walletResponses,nil</span>
}


</pre>
		
		<pre class="file" id="file8" style="display: none">package wallet

import (
        "time"

        "github.com/stretchr/testify/mock"
)

// MockService is a mock implementation of the Service interface
type MockService struct {
        mock.Mock
}

func (m *MockService) GetAllWallets() ([]Wallet, error) <span class="cov8" title="1">{
        args := m.Called()
        return args.Get(0).([]Wallet), args.Error(1)
}</span>

func (m *MockService) GetWalletsByWalletType(walletType string) ([]Wallet, error) <span class="cov0" title="0">{
        args := m.Called(walletType)
        return args.Get(0).([]Wallet), args.Error(1)
}</span>

func (m *MockService) GetWalletsByUserId(userId int) ([]Wallet, error) <span class="cov8" title="1">{
        args := m.Called(userId)
        return args.Get(0).([]Wallet), args.Error(1)
}</span>

func (m *MockService) CreateWallet(wallet *WalletRequest) (*Wallet, error) <span class="cov8" title="1">{
        args := m.Called(wallet)
        return args.Get(0).(*Wallet), args.Error(1)
}</span>

func (m *MockService) DeleteWalletByUserId(userId string) (int64, error) <span class="cov8" title="1">{
        args := m.Called(userId)
        return args.Get(0).(int64), args.Error(1)
}</span>

func (m *MockService) UpdateWalletByWalletId(walletId int, request *WalletRequest) (*Wallet, error) <span class="cov8" title="1">{
        args := m.Called(walletId, request)
        return args.Get(0).(*Wallet), args.Error(1)
}</span>

// Helper function to convert WalletRequest to Wallet
func toWallet(request *WalletRequest) *Wallet <span class="cov0" title="0">{
        return &amp;Wallet{
                ID:         0,
                UserID:     request.UserID,
                UserName:   request.UserName,
                WalletName: request.WalletName,
                WalletType: request.WalletType,
                Balance:    0,
                CreatedAt:  time.Time{},
        }
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package wallet

import (
        "errors"
        "fmt"
        "strings"
)

const (
        minUserNameLength   = 3
        maxUserNameLength   = 255
        minWalletNameLength = 3
        maxWalletNameLength = 255
        minBalance          = 500
        maxBalance          = 10000
)

var validWalletTypes = []string{"Savings", "Credit Card", "Crypto Wallet"}


func ValidateWalletRequest(wallet *WalletRequest) error <span class="cov0" title="0">{
        var errMsgs []string

        if wallet.UserID &lt;= 0 </span><span class="cov0" title="0">{
                errMsgs = append(errMsgs, "UserID must be greater than 0")
        }</span>

        <span class="cov0" title="0">if len(wallet.UserName) &lt; minUserNameLength || len(wallet.UserName) &gt; maxUserNameLength </span><span class="cov0" title="0">{
                errMsgs = append(errMsgs, fmt.Sprintf("UserName must be between %d and %d characters", minUserNameLength, maxUserNameLength))
        }</span>

        <span class="cov0" title="0">if len(wallet.WalletName) &lt; minWalletNameLength || len(wallet.WalletName) &gt; maxWalletNameLength </span><span class="cov0" title="0">{
                errMsgs = append(errMsgs, fmt.Sprintf("WalletName must be between %d and %d characters", minWalletNameLength, maxWalletNameLength))
        }</span>

        <span class="cov0" title="0">if !contains(validWalletTypes, wallet.WalletType) </span><span class="cov0" title="0">{
                errMsgs = append(errMsgs, fmt.Sprintf("WalletType must be one of: %s", strings.Join(validWalletTypes, ", ")))
        }</span>

        <span class="cov0" title="0">if wallet.Balance &lt;= 0 || wallet.Balance &lt; minBalance || wallet.Balance &gt; maxBalance </span><span class="cov0" title="0">{
                errMsgs = append(errMsgs, fmt.Sprintf("Balance must be greater than 0 and between %d and %d", minBalance, maxBalance))
        }</span>

        <span class="cov0" title="0">if len(errMsgs) &gt; 0 </span><span class="cov0" title="0">{
                return errors.New(strings.Join(errMsgs, "; "))
        }</span>


        <span class="cov0" title="0">return nil</span>
}

func contains(arr []string, str string) bool <span class="cov0" title="0">{
        for _, a := range arr </span><span class="cov0" title="0">{
                if a == str </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
